// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package entity

import "context"

type CommitConnection interface {
	TotalCount(context.Context) (int64, error)
	Edges(context.Context) ([]*CommitEdge, error)
	PageInfo(context.Context) (*PageInfo, error)
	Nodes(context.Context) ([]*Commit, error)
}

type CommitEdge struct {
	Node Commit
}

func (e *CommitEdge) Cursor() *string {
	return nodeToCommitCursor(&e.Node)
}

func PageInfoFromCommitEdges(edges []*CommitEdge, hasNext bool, opts *PaginationInput) *PageInfo {
	if len(edges) == 0 {
		return &PageInfo{
			HasNextPage:     opts.Last != nil && opts.Before != nil,
			HasPreviousPage: opts.First != nil && opts.After != nil,
		}
	}

	var page PageInfo

	if opts.Last != nil {
		page.HasPreviousPage = len(edges) == *opts.Last && hasNext
		page.HasNextPage = opts.Before != nil
	} else {
		page.HasPreviousPage = opts.After != nil
		page.HasNextPage = len(edges) == *opts.First && hasNext
	}

	if len(edges) > 0 {
		page.StartEdge = edges[0]
		page.EndEdge = edges[len(edges)-1]
	}

	return &page
}

type PullRequestConnection interface {
	TotalCount(context.Context) (int64, error)
	Edges(context.Context) ([]*PullRequestEdge, error)
	PageInfo(context.Context) (*PageInfo, error)
	Nodes(context.Context) ([]*PullRequest, error)
}

type PullRequestEdge struct {
	Node PullRequest
}

func (e *PullRequestEdge) Cursor() *string {
	return nodeToPullRequestCursor(&e.Node)
}

func PageInfoFromPullRequestEdges(edges []*PullRequestEdge, hasNext bool, opts *PaginationInput) *PageInfo {
	if len(edges) == 0 {
		return &PageInfo{
			HasNextPage:     opts.Last != nil && opts.Before != nil,
			HasPreviousPage: opts.First != nil && opts.After != nil,
		}
	}

	var page PageInfo

	if opts.Last != nil {
		page.HasPreviousPage = len(edges) == *opts.Last && hasNext
		page.HasNextPage = opts.Before != nil
	} else {
		page.HasPreviousPage = opts.After != nil
		page.HasNextPage = len(edges) == *opts.First && hasNext
	}

	if len(edges) > 0 {
		page.StartEdge = edges[0]
		page.EndEdge = edges[len(edges)-1]
	}

	return &page
}

type RepositoryConnection interface {
	TotalCount(context.Context) (int64, error)
	Edges(context.Context) ([]*RepositoryEdge, error)
	PageInfo(context.Context) (*PageInfo, error)
	Nodes(context.Context) ([]*Repository, error)
}

type RepositoryEdge struct {
	Node Repository
}

func (e *RepositoryEdge) Cursor() *string {
	return nodeToRepositoryCursor(&e.Node)
}

func PageInfoFromRepositoryEdges(edges []*RepositoryEdge, hasNext bool, opts *PaginationInput) *PageInfo {
	if len(edges) == 0 {
		return &PageInfo{
			HasNextPage:     opts.Last != nil && opts.Before != nil,
			HasPreviousPage: opts.First != nil && opts.After != nil,
		}
	}

	var page PageInfo

	if opts.Last != nil {
		page.HasPreviousPage = len(edges) == *opts.Last && hasNext
		page.HasNextPage = opts.Before != nil
	} else {
		page.HasPreviousPage = opts.After != nil
		page.HasNextPage = len(edges) == *opts.First && hasNext
	}

	if len(edges) > 0 {
		page.StartEdge = edges[0]
		page.EndEdge = edges[len(edges)-1]
	}

	return &page
}

type JobConnection interface {
	TotalCount(context.Context) (int64, error)
	Edges(context.Context) ([]*JobEdge, error)
	PageInfo(context.Context) (*PageInfo, error)
	Nodes(context.Context) ([]*Job, error)
}

type JobEdge struct {
	Node Job
}

func (e *JobEdge) Cursor() *string {
	return nodeToJobCursor(&e.Node)
}

func PageInfoFromJobEdges(edges []*JobEdge, hasNext bool, opts *PaginationInput) *PageInfo {
	if len(edges) == 0 {
		return &PageInfo{
			HasNextPage:     opts.Last != nil && opts.Before != nil,
			HasPreviousPage: opts.First != nil && opts.After != nil,
		}
	}

	var page PageInfo

	if opts.Last != nil {
		page.HasPreviousPage = len(edges) == *opts.Last && hasNext
		page.HasNextPage = opts.Before != nil
	} else {
		page.HasPreviousPage = opts.After != nil
		page.HasNextPage = len(edges) == *opts.First && hasNext
	}

	if len(edges) > 0 {
		page.StartEdge = edges[0]
		page.EndEdge = edges[len(edges)-1]
	}

	return &page
}

type FeedbackConnection interface {
	TotalCount(context.Context) (int64, error)
	Edges(context.Context) ([]*FeedbackEdge, error)
	PageInfo(context.Context) (*PageInfo, error)
	Nodes(context.Context) ([]*Feedback, error)
}

type FeedbackEdge struct {
	Node Feedback
}

func (e *FeedbackEdge) Cursor() *string {
	return nodeToFeedbackCursor(&e.Node)
}

func PageInfoFromFeedbackEdges(edges []*FeedbackEdge, hasNext bool, opts *PaginationInput) *PageInfo {
	if len(edges) == 0 {
		return &PageInfo{
			HasNextPage:     opts.Last != nil && opts.Before != nil,
			HasPreviousPage: opts.First != nil && opts.After != nil,
		}
	}

	var page PageInfo

	if opts.Last != nil {
		page.HasPreviousPage = len(edges) == *opts.Last && hasNext
		page.HasNextPage = opts.Before != nil
	} else {
		page.HasPreviousPage = opts.After != nil
		page.HasNextPage = len(edges) == *opts.First && hasNext
	}

	if len(edges) > 0 {
		page.StartEdge = edges[0]
		page.EndEdge = edges[len(edges)-1]
	}

	return &page
}

type OrganizationConnection interface {
	TotalCount(context.Context) (int64, error)
	Edges(context.Context) ([]*OrganizationEdge, error)
	PageInfo(context.Context) (*PageInfo, error)
	Nodes(context.Context) ([]*Organization, error)
}

type OrganizationEdge struct {
	Node Organization
}

func (e *OrganizationEdge) Cursor() *string {
	return nodeToOrganizationCursor(&e.Node)
}

func PageInfoFromOrganizationEdges(edges []*OrganizationEdge, hasNext bool, opts *PaginationInput) *PageInfo {
	if len(edges) == 0 {
		return &PageInfo{
			HasNextPage:     opts.Last != nil && opts.Before != nil,
			HasPreviousPage: opts.First != nil && opts.After != nil,
		}
	}

	var page PageInfo

	if opts.Last != nil {
		page.HasPreviousPage = len(edges) == *opts.Last && hasNext
		page.HasNextPage = opts.Before != nil
	} else {
		page.HasPreviousPage = opts.After != nil
		page.HasNextPage = len(edges) == *opts.First && hasNext
	}

	if len(edges) > 0 {
		page.StartEdge = edges[0]
		page.EndEdge = edges[len(edges)-1]
	}

	return &page
}
