// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package mongosrc

import (
	"context"

	"github.com/repofuel/repofuel/ingest/internal/entity"
	"github.com/repofuel/repofuel/pkg/metrics"
	"go.mongodb.org/mongo-driver/mongo"
)

type entityCommitIter struct {
	cur *mongo.Cursor
}

func newEntityCommitIter(cur *mongo.Cursor) *entityCommitIter {
	return &entityCommitIter{cur: cur}
}

func (iter *entityCommitIter) ForEach(ctx context.Context, fun func(*entity.Commit) error) error {
	defer iter.cur.Close(ctx)
	for iter.cur.Next(ctx) {
		var doc entity.Commit
		if err := iter.cur.Decode(&doc); err != nil {
			return err
		}

		if err := fun(&doc); err != nil {
			return err
		}
	}
	return iter.cur.Err()
}

func (iter *entityCommitIter) Slice(ctx context.Context) ([]*entity.Commit, error) {
	s := make([]*entity.Commit, 0, iter.cur.RemainingBatchLength())

	err := iter.ForEach(ctx, func(i *entity.Commit) error {
		s = append(s, i)
		return nil
	})

	return s, err
}

type entityRepositoryIter struct {
	cur *mongo.Cursor
}

func newEntityRepositoryIter(cur *mongo.Cursor) *entityRepositoryIter {
	return &entityRepositoryIter{cur: cur}
}

func (iter *entityRepositoryIter) ForEach(ctx context.Context, fun func(*entity.Repository) error) error {
	defer iter.cur.Close(ctx)
	for iter.cur.Next(ctx) {
		var doc entity.Repository
		if err := iter.cur.Decode(&doc); err != nil {
			return err
		}

		if err := fun(&doc); err != nil {
			return err
		}
	}
	return iter.cur.Err()
}

func (iter *entityRepositoryIter) Slice(ctx context.Context) ([]*entity.Repository, error) {
	s := make([]*entity.Repository, 0, iter.cur.RemainingBatchLength())

	err := iter.ForEach(ctx, func(i *entity.Repository) error {
		s = append(s, i)
		return nil
	})

	return s, err
}

type entityJobIter struct {
	cur *mongo.Cursor
}

func newEntityJobIter(cur *mongo.Cursor) *entityJobIter {
	return &entityJobIter{cur: cur}
}

func (iter *entityJobIter) ForEach(ctx context.Context, fun func(*entity.Job) error) error {
	defer iter.cur.Close(ctx)
	for iter.cur.Next(ctx) {
		var doc entity.Job
		if err := iter.cur.Decode(&doc); err != nil {
			return err
		}

		if err := fun(&doc); err != nil {
			return err
		}
	}
	return iter.cur.Err()
}

func (iter *entityJobIter) Slice(ctx context.Context) ([]*entity.Job, error) {
	s := make([]*entity.Job, 0, iter.cur.RemainingBatchLength())

	err := iter.ForEach(ctx, func(i *entity.Job) error {
		s = append(s, i)
		return nil
	})

	return s, err
}

type entityOrganizationIter struct {
	cur *mongo.Cursor
}

func newEntityOrganizationIter(cur *mongo.Cursor) *entityOrganizationIter {
	return &entityOrganizationIter{cur: cur}
}

func (iter *entityOrganizationIter) ForEach(ctx context.Context, fun func(*entity.Organization) error) error {
	defer iter.cur.Close(ctx)
	for iter.cur.Next(ctx) {
		var doc entity.Organization
		if err := iter.cur.Decode(&doc); err != nil {
			return err
		}

		if err := fun(&doc); err != nil {
			return err
		}
	}
	return iter.cur.Err()
}

func (iter *entityOrganizationIter) Slice(ctx context.Context) ([]*entity.Organization, error) {
	s := make([]*entity.Organization, 0, iter.cur.RemainingBatchLength())

	err := iter.ForEach(ctx, func(i *entity.Organization) error {
		s = append(s, i)
		return nil
	})

	return s, err
}

type entityPullRequestIter struct {
	cur *mongo.Cursor
}

func newEntityPullRequestIter(cur *mongo.Cursor) *entityPullRequestIter {
	return &entityPullRequestIter{cur: cur}
}

func (iter *entityPullRequestIter) ForEach(ctx context.Context, fun func(*entity.PullRequest) error) error {
	defer iter.cur.Close(ctx)
	for iter.cur.Next(ctx) {
		var doc entity.PullRequest
		if err := iter.cur.Decode(&doc); err != nil {
			return err
		}

		if err := fun(&doc); err != nil {
			return err
		}
	}
	return iter.cur.Err()
}

func (iter *entityPullRequestIter) Slice(ctx context.Context) ([]*entity.PullRequest, error) {
	s := make([]*entity.PullRequest, 0, iter.cur.RemainingBatchLength())

	err := iter.ForEach(ctx, func(i *entity.PullRequest) error {
		s = append(s, i)
		return nil
	})

	return s, err
}

type entityDeveloperExpIter struct {
	cur *mongo.Cursor
}

func newEntityDeveloperExpIter(cur *mongo.Cursor) *entityDeveloperExpIter {
	return &entityDeveloperExpIter{cur: cur}
}

func (iter *entityDeveloperExpIter) ForEach(ctx context.Context, fun func(*entity.DeveloperExp) error) error {
	defer iter.cur.Close(ctx)
	for iter.cur.Next(ctx) {
		var doc entity.DeveloperExp
		if err := iter.cur.Decode(&doc); err != nil {
			return err
		}

		if err := fun(&doc); err != nil {
			return err
		}
	}
	return iter.cur.Err()
}

func (iter *entityDeveloperExpIter) Slice(ctx context.Context) ([]*entity.DeveloperExp, error) {
	s := make([]*entity.DeveloperExp, 0, iter.cur.RemainingBatchLength())

	err := iter.ForEach(ctx, func(i *entity.DeveloperExp) error {
		s = append(s, i)
		return nil
	})

	return s, err
}

type entityFileIter struct {
	cur *mongo.Cursor
}

func newEntityFileIter(cur *mongo.Cursor) *entityFileIter {
	return &entityFileIter{cur: cur}
}

func (iter *entityFileIter) ForEach(ctx context.Context, fun func(*entity.File) error) error {
	defer iter.cur.Close(ctx)
	for iter.cur.Next(ctx) {
		var doc entity.File
		if err := iter.cur.Decode(&doc); err != nil {
			return err
		}

		if err := fun(&doc); err != nil {
			return err
		}
	}
	return iter.cur.Err()
}

func (iter *entityFileIter) Slice(ctx context.Context) ([]*entity.File, error) {
	s := make([]*entity.File, 0, iter.cur.RemainingBatchLength())

	err := iter.ForEach(ctx, func(i *entity.File) error {
		s = append(s, i)
		return nil
	})

	return s, err
}

type metricsChangeMeasuresIter struct {
	cur *mongo.Cursor
}

func newMetricsChangeMeasuresIter(cur *mongo.Cursor) *metricsChangeMeasuresIter {
	return &metricsChangeMeasuresIter{cur: cur}
}

func (iter *metricsChangeMeasuresIter) ForEach(ctx context.Context, fun func(*metrics.ChangeMeasures) error) error {
	defer iter.cur.Close(ctx)
	for iter.cur.Next(ctx) {
		var doc metrics.ChangeMeasures
		if err := iter.cur.Decode(&doc); err != nil {
			return err
		}

		if err := fun(&doc); err != nil {
			return err
		}
	}
	return iter.cur.Err()
}

func (iter *metricsChangeMeasuresIter) Slice(ctx context.Context) ([]*metrics.ChangeMeasures, error) {
	s := make([]*metrics.ChangeMeasures, 0, iter.cur.RemainingBatchLength())

	err := iter.ForEach(ctx, func(i *metrics.ChangeMeasures) error {
		s = append(s, i)
		return nil
	})

	return s, err
}

type metricsFileMeasuresIter struct {
	cur *mongo.Cursor
}

func newMetricsFileMeasuresIter(cur *mongo.Cursor) *metricsFileMeasuresIter {
	return &metricsFileMeasuresIter{cur: cur}
}

func (iter *metricsFileMeasuresIter) ForEach(ctx context.Context, fun func(*metrics.FileMeasures) error) error {
	defer iter.cur.Close(ctx)
	for iter.cur.Next(ctx) {
		var doc metrics.FileMeasures
		if err := iter.cur.Decode(&doc); err != nil {
			return err
		}

		if err := fun(&doc); err != nil {
			return err
		}
	}
	return iter.cur.Err()
}

func (iter *metricsFileMeasuresIter) Slice(ctx context.Context) ([]*metrics.FileMeasures, error) {
	s := make([]*metrics.FileMeasures, 0, iter.cur.RemainingBatchLength())

	err := iter.ForEach(ctx, func(i *metrics.FileMeasures) error {
		s = append(s, i)
		return nil
	})

	return s, err
}

type entityFeedbackIter struct {
	cur *mongo.Cursor
}

func newEntityFeedbackIter(cur *mongo.Cursor) *entityFeedbackIter {
	return &entityFeedbackIter{cur: cur}
}

func (iter *entityFeedbackIter) ForEach(ctx context.Context, fun func(*entity.Feedback) error) error {
	defer iter.cur.Close(ctx)
	for iter.cur.Next(ctx) {
		var doc entity.Feedback
		if err := iter.cur.Decode(&doc); err != nil {
			return err
		}

		if err := fun(&doc); err != nil {
			return err
		}
	}
	return iter.cur.Err()
}

func (iter *entityFeedbackIter) Slice(ctx context.Context) ([]*entity.Feedback, error) {
	s := make([]*entity.Feedback, 0, iter.cur.RemainingBatchLength())

	err := iter.ForEach(ctx, func(i *entity.Feedback) error {
		s = append(s, i)
		return nil
	})

	return s, err
}
