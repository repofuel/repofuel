// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package mongosrc

import (
	"context"
	"sync"

	"github.com/repofuel/repofuel/ingest/internal/entity"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
)

type CommitConnection struct {
	collection   *mongo.Collection
	filter       bson.M
	pgInput      *entity.PaginationInput
	orderCfg     *orderDirectionConfig
	cursorParser FuncCursorParser

	edges   []*entity.CommitEdge
	hasNext bool
	once    sync.Once
}

func newCommitConnection(collection *mongo.Collection, filter bson.M, pgInput *entity.PaginationInput, orderCfg *orderDirectionConfig, cursorParser FuncCursorParser) *CommitConnection {
	return &CommitConnection{
		collection:   collection,
		filter:       filter,
		pgInput:      pgInput,
		orderCfg:     orderCfg,
		cursorParser: cursorParser,
	}
}

func (c *CommitConnection) TotalCount(ctx context.Context) (int64, error) {
	return c.collection.CountDocuments(ctx, c.filter)
}

func (c *CommitConnection) Edges(ctx context.Context) ([]*entity.CommitEdge, error) {
	var err error

	c.once.Do(func() {
		c.edges, c.hasNext, err = findCommitEdges(ctx, c.collection, c.filter, c.pgInput, c.orderCfg, c.cursorParser)
	})

	return c.edges, err
}

func (c *CommitConnection) PageInfo(ctx context.Context) (*entity.PageInfo, error) {
	edges, err := c.Edges(ctx)
	if err != nil {
		return nil, err
	}

	return entity.PageInfoFromCommitEdges(edges, c.hasNext, c.pgInput), nil
}

func (c *CommitConnection) Nodes(ctx context.Context) ([]*entity.Commit, error) {
	edges, err := c.Edges(ctx)
	if err != nil {
		return nil, err
	}

	nodes := make([]*entity.Commit, len(edges))
	for i := range edges {
		nodes[i] = &edges[i].Node
	}
	return nodes, nil
}

func findCommitEdges(ctx context.Context, collection *mongo.Collection, filter bson.M, pgInput *entity.PaginationInput, orderCfg *orderDirectionConfig, cursorParser FuncCursorParser) ([]*entity.CommitEdge, bool, error) {
	err := pgInput.Validate("Commits", 100)
	if err != nil {
		return nil, false, err
	}

	mongoOpts := options.Find()

	filter = copyBsonM(filter) //fixme: should have a better solution
	err = applyPaginationOptions(mongoOpts, filter, pgInput, orderCfg, cursorParser)
	if err != nil {
		return nil, false, err
	}

	//todo: apply projection

	cur, err := collection.Find(ctx, filter, mongoOpts)
	if err != nil {
		if err, ok := err.(mongo.CommandError); ok && err.Code == 51175 {
			// no results
			return make([]*entity.CommitEdge, 0), false, nil
		}
		return nil, false, err
	}
	defer cur.Close(ctx)

	edges, err := getSortedCommitEdges(ctx, cur, pgInput)
	if err != nil {
		return nil, false, err
	}

	return edges, cur.Next(ctx), err
}

func getSortedCommitEdges(ctx context.Context, cur *mongo.Cursor, opts *entity.PaginationInput) ([]*entity.CommitEdge, error) {
	if opts.Last != nil {
		return backwardCommitEdges(ctx, cur, opts)
	}

	return forwardCommitEdges(ctx, cur, opts)
}

func forwardCommitEdges(ctx context.Context, cur *mongo.Cursor, opts *entity.PaginationInput) ([]*entity.CommitEdge, error) {
	var limit = *opts.First
	var edges = make([]*entity.CommitEdge, limit)
	var index = 0

	for index < limit && cur.Next(ctx) {
		var edge entity.CommitEdge
		err := cur.Decode(&edge.Node)
		if err != nil {
			return nil, err
		}
		edges[index] = &edge
		index++
	}
	edges = edges[:index]

	return edges, nil
}

func backwardCommitEdges(ctx context.Context, cur *mongo.Cursor, opts *entity.PaginationInput) ([]*entity.CommitEdge, error) {
	var limit = *opts.Last
	var edges = make([]*entity.CommitEdge, limit)
	var index = limit - 1

	for index >= 0 && cur.Next(ctx) {
		var c entity.CommitEdge
		err := cur.Decode(&c.Node)
		if err != nil {
			return nil, err
		}
		edges[index] = &c
		index--
	}
	edges = edges[index+1:]

	return edges, nil
}

type PullRequestConnection struct {
	collection   *mongo.Collection
	filter       bson.M
	pgInput      *entity.PaginationInput
	orderCfg     *orderDirectionConfig
	cursorParser FuncCursorParser

	edges   []*entity.PullRequestEdge
	hasNext bool
	once    sync.Once
}

func newPullRequestConnection(collection *mongo.Collection, filter bson.M, pgInput *entity.PaginationInput, orderCfg *orderDirectionConfig, cursorParser FuncCursorParser) *PullRequestConnection {
	return &PullRequestConnection{
		collection:   collection,
		filter:       filter,
		pgInput:      pgInput,
		orderCfg:     orderCfg,
		cursorParser: cursorParser,
	}
}

func (c *PullRequestConnection) TotalCount(ctx context.Context) (int64, error) {
	return c.collection.CountDocuments(ctx, c.filter)
}

func (c *PullRequestConnection) Edges(ctx context.Context) ([]*entity.PullRequestEdge, error) {
	var err error

	c.once.Do(func() {
		c.edges, c.hasNext, err = findPullRequestEdges(ctx, c.collection, c.filter, c.pgInput, c.orderCfg, c.cursorParser)
	})

	return c.edges, err
}

func (c *PullRequestConnection) PageInfo(ctx context.Context) (*entity.PageInfo, error) {
	edges, err := c.Edges(ctx)
	if err != nil {
		return nil, err
	}

	return entity.PageInfoFromPullRequestEdges(edges, c.hasNext, c.pgInput), nil
}

func (c *PullRequestConnection) Nodes(ctx context.Context) ([]*entity.PullRequest, error) {
	edges, err := c.Edges(ctx)
	if err != nil {
		return nil, err
	}

	nodes := make([]*entity.PullRequest, len(edges))
	for i := range edges {
		nodes[i] = &edges[i].Node
	}
	return nodes, nil
}

func findPullRequestEdges(ctx context.Context, collection *mongo.Collection, filter bson.M, pgInput *entity.PaginationInput, orderCfg *orderDirectionConfig, cursorParser FuncCursorParser) ([]*entity.PullRequestEdge, bool, error) {
	err := pgInput.Validate("PullRequests", 100)
	if err != nil {
		return nil, false, err
	}

	mongoOpts := options.Find()

	filter = copyBsonM(filter) //fixme: should have a better solution
	err = applyPaginationOptions(mongoOpts, filter, pgInput, orderCfg, cursorParser)
	if err != nil {
		return nil, false, err
	}

	//todo: apply projection

	cur, err := collection.Find(ctx, filter, mongoOpts)
	if err != nil {
		if err, ok := err.(mongo.CommandError); ok && err.Code == 51175 {
			// no results
			return make([]*entity.PullRequestEdge, 0), false, nil
		}
		return nil, false, err
	}
	defer cur.Close(ctx)

	edges, err := getSortedPullRequestEdges(ctx, cur, pgInput)
	if err != nil {
		return nil, false, err
	}

	return edges, cur.Next(ctx), err
}

func getSortedPullRequestEdges(ctx context.Context, cur *mongo.Cursor, opts *entity.PaginationInput) ([]*entity.PullRequestEdge, error) {
	if opts.Last != nil {
		return backwardPullRequestEdges(ctx, cur, opts)
	}

	return forwardPullRequestEdges(ctx, cur, opts)
}

func forwardPullRequestEdges(ctx context.Context, cur *mongo.Cursor, opts *entity.PaginationInput) ([]*entity.PullRequestEdge, error) {
	var limit = *opts.First
	var edges = make([]*entity.PullRequestEdge, limit)
	var index = 0

	for index < limit && cur.Next(ctx) {
		var edge entity.PullRequestEdge
		err := cur.Decode(&edge.Node)
		if err != nil {
			return nil, err
		}
		edges[index] = &edge
		index++
	}
	edges = edges[:index]

	return edges, nil
}

func backwardPullRequestEdges(ctx context.Context, cur *mongo.Cursor, opts *entity.PaginationInput) ([]*entity.PullRequestEdge, error) {
	var limit = *opts.Last
	var edges = make([]*entity.PullRequestEdge, limit)
	var index = limit - 1

	for index >= 0 && cur.Next(ctx) {
		var c entity.PullRequestEdge
		err := cur.Decode(&c.Node)
		if err != nil {
			return nil, err
		}
		edges[index] = &c
		index--
	}
	edges = edges[index+1:]

	return edges, nil
}

type RepositoryConnection struct {
	collection   *mongo.Collection
	filter       bson.M
	pgInput      *entity.PaginationInput
	orderCfg     *orderDirectionConfig
	cursorParser FuncCursorParser

	edges   []*entity.RepositoryEdge
	hasNext bool
	once    sync.Once
}

func newRepositoryConnection(collection *mongo.Collection, filter bson.M, pgInput *entity.PaginationInput, orderCfg *orderDirectionConfig, cursorParser FuncCursorParser) *RepositoryConnection {
	return &RepositoryConnection{
		collection:   collection,
		filter:       filter,
		pgInput:      pgInput,
		orderCfg:     orderCfg,
		cursorParser: cursorParser,
	}
}

func (c *RepositoryConnection) TotalCount(ctx context.Context) (int64, error) {
	return c.collection.CountDocuments(ctx, c.filter)
}

func (c *RepositoryConnection) Edges(ctx context.Context) ([]*entity.RepositoryEdge, error) {
	var err error

	c.once.Do(func() {
		c.edges, c.hasNext, err = findRepositoryEdges(ctx, c.collection, c.filter, c.pgInput, c.orderCfg, c.cursorParser)
	})

	return c.edges, err
}

func (c *RepositoryConnection) PageInfo(ctx context.Context) (*entity.PageInfo, error) {
	edges, err := c.Edges(ctx)
	if err != nil {
		return nil, err
	}

	return entity.PageInfoFromRepositoryEdges(edges, c.hasNext, c.pgInput), nil
}

func (c *RepositoryConnection) Nodes(ctx context.Context) ([]*entity.Repository, error) {
	edges, err := c.Edges(ctx)
	if err != nil {
		return nil, err
	}

	nodes := make([]*entity.Repository, len(edges))
	for i := range edges {
		nodes[i] = &edges[i].Node
	}
	return nodes, nil
}

func findRepositoryEdges(ctx context.Context, collection *mongo.Collection, filter bson.M, pgInput *entity.PaginationInput, orderCfg *orderDirectionConfig, cursorParser FuncCursorParser) ([]*entity.RepositoryEdge, bool, error) {
	err := pgInput.Validate("Repositorys", 100)
	if err != nil {
		return nil, false, err
	}

	mongoOpts := options.Find()

	filter = copyBsonM(filter) //fixme: should have a better solution
	err = applyPaginationOptions(mongoOpts, filter, pgInput, orderCfg, cursorParser)
	if err != nil {
		return nil, false, err
	}

	//todo: apply projection

	cur, err := collection.Find(ctx, filter, mongoOpts)
	if err != nil {
		if err, ok := err.(mongo.CommandError); ok && err.Code == 51175 {
			// no results
			return make([]*entity.RepositoryEdge, 0), false, nil
		}
		return nil, false, err
	}
	defer cur.Close(ctx)

	edges, err := getSortedRepositoryEdges(ctx, cur, pgInput)
	if err != nil {
		return nil, false, err
	}

	return edges, cur.Next(ctx), err
}

func getSortedRepositoryEdges(ctx context.Context, cur *mongo.Cursor, opts *entity.PaginationInput) ([]*entity.RepositoryEdge, error) {
	if opts.Last != nil {
		return backwardRepositoryEdges(ctx, cur, opts)
	}

	return forwardRepositoryEdges(ctx, cur, opts)
}

func forwardRepositoryEdges(ctx context.Context, cur *mongo.Cursor, opts *entity.PaginationInput) ([]*entity.RepositoryEdge, error) {
	var limit = *opts.First
	var edges = make([]*entity.RepositoryEdge, limit)
	var index = 0

	for index < limit && cur.Next(ctx) {
		var edge entity.RepositoryEdge
		err := cur.Decode(&edge.Node)
		if err != nil {
			return nil, err
		}
		edges[index] = &edge
		index++
	}
	edges = edges[:index]

	return edges, nil
}

func backwardRepositoryEdges(ctx context.Context, cur *mongo.Cursor, opts *entity.PaginationInput) ([]*entity.RepositoryEdge, error) {
	var limit = *opts.Last
	var edges = make([]*entity.RepositoryEdge, limit)
	var index = limit - 1

	for index >= 0 && cur.Next(ctx) {
		var c entity.RepositoryEdge
		err := cur.Decode(&c.Node)
		if err != nil {
			return nil, err
		}
		edges[index] = &c
		index--
	}
	edges = edges[index+1:]

	return edges, nil
}

type JobConnection struct {
	collection   *mongo.Collection
	filter       bson.M
	pgInput      *entity.PaginationInput
	orderCfg     *orderDirectionConfig
	cursorParser FuncCursorParser

	edges   []*entity.JobEdge
	hasNext bool
	once    sync.Once
}

func newJobConnection(collection *mongo.Collection, filter bson.M, pgInput *entity.PaginationInput, orderCfg *orderDirectionConfig, cursorParser FuncCursorParser) *JobConnection {
	return &JobConnection{
		collection:   collection,
		filter:       filter,
		pgInput:      pgInput,
		orderCfg:     orderCfg,
		cursorParser: cursorParser,
	}
}

func (c *JobConnection) TotalCount(ctx context.Context) (int64, error) {
	return c.collection.CountDocuments(ctx, c.filter)
}

func (c *JobConnection) Edges(ctx context.Context) ([]*entity.JobEdge, error) {
	var err error

	c.once.Do(func() {
		c.edges, c.hasNext, err = findJobEdges(ctx, c.collection, c.filter, c.pgInput, c.orderCfg, c.cursorParser)
	})

	return c.edges, err
}

func (c *JobConnection) PageInfo(ctx context.Context) (*entity.PageInfo, error) {
	edges, err := c.Edges(ctx)
	if err != nil {
		return nil, err
	}

	return entity.PageInfoFromJobEdges(edges, c.hasNext, c.pgInput), nil
}

func (c *JobConnection) Nodes(ctx context.Context) ([]*entity.Job, error) {
	edges, err := c.Edges(ctx)
	if err != nil {
		return nil, err
	}

	nodes := make([]*entity.Job, len(edges))
	for i := range edges {
		nodes[i] = &edges[i].Node
	}
	return nodes, nil
}

func findJobEdges(ctx context.Context, collection *mongo.Collection, filter bson.M, pgInput *entity.PaginationInput, orderCfg *orderDirectionConfig, cursorParser FuncCursorParser) ([]*entity.JobEdge, bool, error) {
	err := pgInput.Validate("Jobs", 100)
	if err != nil {
		return nil, false, err
	}

	mongoOpts := options.Find()

	filter = copyBsonM(filter) //fixme: should have a better solution
	err = applyPaginationOptions(mongoOpts, filter, pgInput, orderCfg, cursorParser)
	if err != nil {
		return nil, false, err
	}

	//todo: apply projection

	cur, err := collection.Find(ctx, filter, mongoOpts)
	if err != nil {
		if err, ok := err.(mongo.CommandError); ok && err.Code == 51175 {
			// no results
			return make([]*entity.JobEdge, 0), false, nil
		}
		return nil, false, err
	}
	defer cur.Close(ctx)

	edges, err := getSortedJobEdges(ctx, cur, pgInput)
	if err != nil {
		return nil, false, err
	}

	return edges, cur.Next(ctx), err
}

func getSortedJobEdges(ctx context.Context, cur *mongo.Cursor, opts *entity.PaginationInput) ([]*entity.JobEdge, error) {
	if opts.Last != nil {
		return backwardJobEdges(ctx, cur, opts)
	}

	return forwardJobEdges(ctx, cur, opts)
}

func forwardJobEdges(ctx context.Context, cur *mongo.Cursor, opts *entity.PaginationInput) ([]*entity.JobEdge, error) {
	var limit = *opts.First
	var edges = make([]*entity.JobEdge, limit)
	var index = 0

	for index < limit && cur.Next(ctx) {
		var edge entity.JobEdge
		err := cur.Decode(&edge.Node)
		if err != nil {
			return nil, err
		}
		edges[index] = &edge
		index++
	}
	edges = edges[:index]

	return edges, nil
}

func backwardJobEdges(ctx context.Context, cur *mongo.Cursor, opts *entity.PaginationInput) ([]*entity.JobEdge, error) {
	var limit = *opts.Last
	var edges = make([]*entity.JobEdge, limit)
	var index = limit - 1

	for index >= 0 && cur.Next(ctx) {
		var c entity.JobEdge
		err := cur.Decode(&c.Node)
		if err != nil {
			return nil, err
		}
		edges[index] = &c
		index--
	}
	edges = edges[index+1:]

	return edges, nil
}

type FeedbackConnection struct {
	collection   *mongo.Collection
	filter       bson.M
	pgInput      *entity.PaginationInput
	orderCfg     *orderDirectionConfig
	cursorParser FuncCursorParser

	edges   []*entity.FeedbackEdge
	hasNext bool
	once    sync.Once
}

func newFeedbackConnection(collection *mongo.Collection, filter bson.M, pgInput *entity.PaginationInput, orderCfg *orderDirectionConfig, cursorParser FuncCursorParser) *FeedbackConnection {
	return &FeedbackConnection{
		collection:   collection,
		filter:       filter,
		pgInput:      pgInput,
		orderCfg:     orderCfg,
		cursorParser: cursorParser,
	}
}

func (c *FeedbackConnection) TotalCount(ctx context.Context) (int64, error) {
	return c.collection.CountDocuments(ctx, c.filter)
}

func (c *FeedbackConnection) Edges(ctx context.Context) ([]*entity.FeedbackEdge, error) {
	var err error

	c.once.Do(func() {
		c.edges, c.hasNext, err = findFeedbackEdges(ctx, c.collection, c.filter, c.pgInput, c.orderCfg, c.cursorParser)
	})

	return c.edges, err
}

func (c *FeedbackConnection) PageInfo(ctx context.Context) (*entity.PageInfo, error) {
	edges, err := c.Edges(ctx)
	if err != nil {
		return nil, err
	}

	return entity.PageInfoFromFeedbackEdges(edges, c.hasNext, c.pgInput), nil
}

func (c *FeedbackConnection) Nodes(ctx context.Context) ([]*entity.Feedback, error) {
	edges, err := c.Edges(ctx)
	if err != nil {
		return nil, err
	}

	nodes := make([]*entity.Feedback, len(edges))
	for i := range edges {
		nodes[i] = &edges[i].Node
	}
	return nodes, nil
}

func findFeedbackEdges(ctx context.Context, collection *mongo.Collection, filter bson.M, pgInput *entity.PaginationInput, orderCfg *orderDirectionConfig, cursorParser FuncCursorParser) ([]*entity.FeedbackEdge, bool, error) {
	err := pgInput.Validate("Feedbacks", 100)
	if err != nil {
		return nil, false, err
	}

	mongoOpts := options.Find()

	filter = copyBsonM(filter) //fixme: should have a better solution
	err = applyPaginationOptions(mongoOpts, filter, pgInput, orderCfg, cursorParser)
	if err != nil {
		return nil, false, err
	}

	//todo: apply projection

	cur, err := collection.Find(ctx, filter, mongoOpts)
	if err != nil {
		if err, ok := err.(mongo.CommandError); ok && err.Code == 51175 {
			// no results
			return make([]*entity.FeedbackEdge, 0), false, nil
		}
		return nil, false, err
	}
	defer cur.Close(ctx)

	edges, err := getSortedFeedbackEdges(ctx, cur, pgInput)
	if err != nil {
		return nil, false, err
	}

	return edges, cur.Next(ctx), err
}

func getSortedFeedbackEdges(ctx context.Context, cur *mongo.Cursor, opts *entity.PaginationInput) ([]*entity.FeedbackEdge, error) {
	if opts.Last != nil {
		return backwardFeedbackEdges(ctx, cur, opts)
	}

	return forwardFeedbackEdges(ctx, cur, opts)
}

func forwardFeedbackEdges(ctx context.Context, cur *mongo.Cursor, opts *entity.PaginationInput) ([]*entity.FeedbackEdge, error) {
	var limit = *opts.First
	var edges = make([]*entity.FeedbackEdge, limit)
	var index = 0

	for index < limit && cur.Next(ctx) {
		var edge entity.FeedbackEdge
		err := cur.Decode(&edge.Node)
		if err != nil {
			return nil, err
		}
		edges[index] = &edge
		index++
	}
	edges = edges[:index]

	return edges, nil
}

func backwardFeedbackEdges(ctx context.Context, cur *mongo.Cursor, opts *entity.PaginationInput) ([]*entity.FeedbackEdge, error) {
	var limit = *opts.Last
	var edges = make([]*entity.FeedbackEdge, limit)
	var index = limit - 1

	for index >= 0 && cur.Next(ctx) {
		var c entity.FeedbackEdge
		err := cur.Decode(&c.Node)
		if err != nil {
			return nil, err
		}
		edges[index] = &c
		index--
	}
	edges = edges[index+1:]

	return edges, nil
}

type OrganizationConnection struct {
	collection   *mongo.Collection
	filter       bson.M
	pgInput      *entity.PaginationInput
	orderCfg     *orderDirectionConfig
	cursorParser FuncCursorParser

	edges   []*entity.OrganizationEdge
	hasNext bool
	once    sync.Once
}

func newOrganizationConnection(collection *mongo.Collection, filter bson.M, pgInput *entity.PaginationInput, orderCfg *orderDirectionConfig, cursorParser FuncCursorParser) *OrganizationConnection {
	return &OrganizationConnection{
		collection:   collection,
		filter:       filter,
		pgInput:      pgInput,
		orderCfg:     orderCfg,
		cursorParser: cursorParser,
	}
}

func (c *OrganizationConnection) TotalCount(ctx context.Context) (int64, error) {
	return c.collection.CountDocuments(ctx, c.filter)
}

func (c *OrganizationConnection) Edges(ctx context.Context) ([]*entity.OrganizationEdge, error) {
	var err error

	c.once.Do(func() {
		c.edges, c.hasNext, err = findOrganizationEdges(ctx, c.collection, c.filter, c.pgInput, c.orderCfg, c.cursorParser)
	})

	return c.edges, err
}

func (c *OrganizationConnection) PageInfo(ctx context.Context) (*entity.PageInfo, error) {
	edges, err := c.Edges(ctx)
	if err != nil {
		return nil, err
	}

	return entity.PageInfoFromOrganizationEdges(edges, c.hasNext, c.pgInput), nil
}

func (c *OrganizationConnection) Nodes(ctx context.Context) ([]*entity.Organization, error) {
	edges, err := c.Edges(ctx)
	if err != nil {
		return nil, err
	}

	nodes := make([]*entity.Organization, len(edges))
	for i := range edges {
		nodes[i] = &edges[i].Node
	}
	return nodes, nil
}

func findOrganizationEdges(ctx context.Context, collection *mongo.Collection, filter bson.M, pgInput *entity.PaginationInput, orderCfg *orderDirectionConfig, cursorParser FuncCursorParser) ([]*entity.OrganizationEdge, bool, error) {
	err := pgInput.Validate("Organizations", 100)
	if err != nil {
		return nil, false, err
	}

	mongoOpts := options.Find()

	filter = copyBsonM(filter) //fixme: should have a better solution
	err = applyPaginationOptions(mongoOpts, filter, pgInput, orderCfg, cursorParser)
	if err != nil {
		return nil, false, err
	}

	//todo: apply projection

	cur, err := collection.Find(ctx, filter, mongoOpts)
	if err != nil {
		if err, ok := err.(mongo.CommandError); ok && err.Code == 51175 {
			// no results
			return make([]*entity.OrganizationEdge, 0), false, nil
		}
		return nil, false, err
	}
	defer cur.Close(ctx)

	edges, err := getSortedOrganizationEdges(ctx, cur, pgInput)
	if err != nil {
		return nil, false, err
	}

	return edges, cur.Next(ctx), err
}

func getSortedOrganizationEdges(ctx context.Context, cur *mongo.Cursor, opts *entity.PaginationInput) ([]*entity.OrganizationEdge, error) {
	if opts.Last != nil {
		return backwardOrganizationEdges(ctx, cur, opts)
	}

	return forwardOrganizationEdges(ctx, cur, opts)
}

func forwardOrganizationEdges(ctx context.Context, cur *mongo.Cursor, opts *entity.PaginationInput) ([]*entity.OrganizationEdge, error) {
	var limit = *opts.First
	var edges = make([]*entity.OrganizationEdge, limit)
	var index = 0

	for index < limit && cur.Next(ctx) {
		var edge entity.OrganizationEdge
		err := cur.Decode(&edge.Node)
		if err != nil {
			return nil, err
		}
		edges[index] = &edge
		index++
	}
	edges = edges[:index]

	return edges, nil
}

func backwardOrganizationEdges(ctx context.Context, cur *mongo.Cursor, opts *entity.PaginationInput) ([]*entity.OrganizationEdge, error) {
	var limit = *opts.Last
	var edges = make([]*entity.OrganizationEdge, limit)
	var index = limit - 1

	for index >= 0 && cur.Next(ctx) {
		var c entity.OrganizationEdge
		err := cur.Decode(&c.Node)
		if err != nil {
			return nil, err
		}
		edges[index] = &c
		index--
	}
	edges = edges[index+1:]

	return edges, nil
}
